## 1.文件锁
在Linux系统中，当多个用户或进程同时访问、操作同一个文件时，就像多个人同时在编辑一份重要的共享文档一样，很容易发生数据混乱和不一致。为了避免这种“竞争状态”的发生，确保数据的完整性和可靠性，Linux引入了一套精妙而强大的机制——**文件锁（File Locks）**。

文件锁主要分为两大类，它们在实现机制和应用场景上各有侧重：

| 类型       | 建议性锁 (Advisory Locks)                      | 强制性锁 (Mandatory Locks)               |
| -------- | ------------------------------------------ | ------------------------------------ |
| **工作原理** | 要求所有使用该文件的进程都“自觉”地检查并遵守锁的存在。就像君子协定，需要各方配合。 | 由内核强制执行。当文件被加锁进行写入操作时，内核会阻止其他任何读写操作。 |
| **内核参与** | 内核和系统通常不主动使用，不检查锁状态。                       | 内核会主动检查并执行锁，确保排他性。                   |
| **性能影响** | 不涉及内核的频繁检查，性能开销小。                          | 每次读写操作都需要内核检查锁状态，性能影响较大。             |
| **应用场景** | 适用于所有参与进程都高度信任且协同工作的环境，例如数据库系统内部的锁管理。      | 适用于需要严格控制访问、确保数据一致性的场景，但需权衡性能。       |
| **可靠性**  | 依赖于应用程序的正确实现和配合，如果某个进程不遵守规则，锁将失效。          | 由内核保证，可靠性高，但可能影响并发性能。                |

## 2. fcntl()函数
`fcntl()` 函数不仅可以施加**建议性锁**，还可以施加**强制性锁**。`fcntl()`之所以强大，很大程度上得益于它对**记录锁**的支持。记录锁允许我们对文件的**特定部分**进行上锁，这对于处理大型文件或多进程协作修改文件不同区域的场景尤为重要。记录锁又细分为两种类型：
1. **读取锁（共享锁 ）**
    - **特性**：顾名思义，这是一种“共享”的锁。它允许**多个进程**在文件的同一部分同时建立读取锁。可以理解成大家可以同时“阅读”文件中的某个章节，互不干扰。
        
    - **应用**：适用于文件区域的并发读取操作，提高系统的并发性。
        
2. **写入锁（排斥锁 ）**
    - **特性**：这是一种“排斥”的锁。在任何时刻，文件的某个部分**只能有一个进程**建立写入锁。就像只有一个作者能修改这份文档的某个段落，其他人必须等待。
        
    - **互斥性**：这里有一个关键原则——在文件的**同一部分**，**不能同时建立读取锁和写入锁**。这意味着，当有程序正在修改某个区域时，其他程序既不能读，也不能写；反之，当有人正在读取某个区域时，其他人可以同时读，但不能写。

`fcntl`函数原型定义在`<fcntl.h>`头文件中：
``` C
#include <fcntl.h>

int fcntl(int fd, int cmd, ... );
```

### a. int fd参数
文件描述符，通过`open()`等函数的调用返回的整数。

### b. int cmd参数
`fcntl()`函数的控制命令。这是一个整数常量，决定了 `fcntl` 要执行哪种操作。不同的 `cmd` 决定了是否需要第三个参数以及第三个参数的类型。
* `F_DUPFD`：复制文件描述符。
* `F_GETFD`：获取文件描述符标志。目前只有一个标志：`FD_CLOEXEC`。
* `F_SETFD`：设置文件描述符标志。第三个参数 `arg` (整型) 是新的标志值。
* `F_GETFL`: 获取文件状态标志，例如 `O_NONBLOCK`, `O_APPEND`, `O_ASYNC` 等。
* `F_SETFL`: 设置文件状态标志。可以用来添加或移除某些标志。
* `F_GETLK`: 测试锁。用于检查文件某区域是否可以被锁定。它不会真的去加锁，而是检查是否存在会阻止当前加锁请求的锁。如果存在冲突，`flock` 结构体的内容会被能够阻止加锁的那个锁的信息覆盖
* `F_SETLK`: **非阻塞**地设置或释放锁。如果无法立即获得锁（例如，已被其他进程锁定），它会立即返回 `-1` 并将 `errno` 设置为 `EACCES` 或 `EAGAIN`。
* `F_SETLKW`: **阻塞**地设置或释放锁。如果无法立即获得锁，调用进程会被挂起，直到成功获取锁为止。

### c. 可变参数
`fcntl` 是一个**可变参数函数**，就像我们常用的 `printf` 和 `scanf` 一样。这意味着它后续的**类型和数量是不固定的**，完全取决于第二个参数 `cmd` 的值。fcntl函数用法对照表：

| `cmd` 值           | 第三个参数 `arg` 的类型  | 功能说明                                         |
| :---------------- | :--------------- | :------------------------------------------- |
| **文件锁相关**         |                  |                                              |
| `F_SETLK`         | `struct flock *` | **设置**或**释放**一个**非阻塞**的文件锁。                  |
| `F_SETLKW`        | `struct flock *` | **设置**或**释放**一个**阻塞**的文件锁。                   |
| `F_GETLK`         | `struct flock *` | **测试**是否存在一个会与参数指定的锁产生冲突的锁。                  |
| **文件描述符/状态标志**    |                  |                                              |
| `F_SETFD`         | `int`            | 设置**文件描述符标志** 。                              |
| `F_GETFD`         | **(无)**          | 获取**文件描述符标志**。                               |
| `F_SETFL`         | `int`            | 设置**文件状态标志** 。                               |
| `F_GETFL`         | **(无)**          | 获取**文件状态标志**。                                |
| **文件描述符复制**       |                  |                                              |
| `F_DUPFD`         | `int`            | 复制文件描述符 `fd`，返回大于或等于 `arg` 的最小可用新描述符。        |
| `F_DUPFD_CLOEXEC` | `int`            | 功能同 `F_DUPFD`，但为新的文件描述符自动设置 `FD_CLOEXEC` 标志。 |
| **I/O 信号相关**      |                  |                                              |
| `F_SETOWN`        | `int`            | 设置将接收 `SIGIO` 和 `SIGURG` 信号的进程ID或进程组ID。      |
| `F_GETOWN`        | **(无)**          | 获取将接收 `SIGIO` 和 `SIGURG` 信号的进程ID或进程组ID。      |
|                   |                  |                                              |

要使用`fcntl()`函数对文件进行加锁、解锁或者查询锁状态时，需要通过一个`struct flock`类型的变量传递给`fcntl()`函数。
`struct flock`在`<fcntl.h>`的定义如下：
``` C
struct flock {
    short   l_type;    // 锁的类型
    short   l_whence;  // 偏移量基准
    off_t   l_start;   // 锁的起始偏移 
    off_t   l_len;     // 锁的长度
    pid_t   l_pid;     // 持有锁的进程ID 
};
```

`struct flock`内容总结如下：

| 成员         | 类型      | 描述和用途                                                                                                                                                         |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `l_type`   | `short` | **锁的操作类型**，决定了是加锁、解锁还是查询。<ul><li>`F_RDLCK`：设置**共享读锁**。允许多个进程同时持有。</li><li>`F_WRLCK`：设置**独占写锁**。同一时间只允许一个进程持有。</li><li>`F_UNLCK`：**解锁**指定的区域。</li></ul>        |
| `l_whence` | `short` | **定义 `l_start` 的计算基准**，与 `lseek()` 类似。<ul><li>`SEEK_SET`：从文件**开头**计算。</li><li>`SEEK_CUR`：从文件**当前**偏移量计算。</li><li>`SEEK_END`：从文件**末尾**计算。</li></ul>            |
| `l_start`  | `off_t` | **锁区域的起始偏移量**，以字节为单位，根据 `l_whence` 计算。可以是正数或负数。                                                                                                               |
| `l_len`    | `off_t` | **锁区域的长度**，以字节为单位。<ul><li>**正数**：从 `l_start` 开始向后锁定的字节数。</li><li>**0 (零)**：特殊值，表示从 `l_start` 开始一直锁到**文件末尾**。</li><li>**负数**：从 `l_start` 开始向前锁定的字节数。</li></ul> |
| `l_pid`    | `pid_t` | **持有锁的进程 ID**。这个成员**只在 `F_GETLK` 命令中使用**，由内核填充。当 `F_GETLK` 检测到锁冲突时，此字段会被设置为持有该冲突锁的进程的 PID。在设置锁时（`F_SETLK`, `F_SETLKW`），此字段被忽略。                                |

### d. 返回值
- **成功时**：返回值取决于 `cmd` 的具体命令。
    - 例如，获取标志时返回标志值；复制文件描述符时返回新的文件描述符。
    - 对于不返回值的命令（如设置标志），成功时通常返回 0。
        
- **失败时**：返回 `-1`，并设置全局变量 `errno` 来指示错误原因。

## 3.实验内容

## a.编译程序
在Linux源码根目录下打开终端，输入如下命令：
``` shell
cd ./linux/application/lock
gcc -o write_lock write_lock.c
gcc -o read_lock read_lock.c
```

### b.写入锁
在`./linux/application/lock`目录下打开两个终端，两个终端都输入命令
``` shell
./write_lock
```
在第一个输入命令的终端中按下任意按键即可解除锁，第二个终端会给文件上锁
![[Pasted image 20250714172202.png]]
由此可见，写入锁为互斥锁，某个文件同一时刻只能有一个写入锁。

### c.读取锁
在两个终端中输入以下命令：
``` shell
./read_lock
```
两个进程均可以为文件上读取锁
![[Pasted image 20250714172603.png]]
验证了读取锁为共享锁。

## 4.实验拓展
在我们实验四拓展实验的基础上，在程序写入时为文件添加一个写入锁。