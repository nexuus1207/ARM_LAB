## 一、经典IO模型
I/O (Input/Output) 模型描述的是应用程序与操作系统内核之间如何完成输入输出操作的机制。一个典型的网络 I/O 操作，比如从网络套接字（Socket）读取数据，通常包含两个阶段：

1. **等待数据就绪**：内核等待网络数据包到达网卡，然后将其复制到内核的缓冲区。
    
2. **数据拷贝**：内核将数据从其内部缓冲区复制到应用程序指定的内存地址。
不同的 I/O 模型在这两个阶段中，应用程序和内核的协作方式不同，从而导致了性能和资源使用上的巨大差异。
>[!note]- 同步 vs 异步
>* **同步**：应用程序**自己**发起 I/O 操作后，必须等待或主动轮询，直到数据拷贝阶段完成，才能拿到最终数据。重点在于**应用需要自己处理数据拷贝**。
>*  **异步**：应用程序发起 I/O 操作后，可以立即返回去做其他事。内核会**独立完成**上述的两个阶段（等待数据和拷贝数据），当一切都完成后，再通过回调函数或信号等方式**通知**应用程序。重点在于**内核替应用完成了所有工作**。

>[!note]- 阻塞 vs 非阻塞
>* **阻塞**：应用程序调用 I/O 函数后，如果数据还没准备好，线程会被**挂起**，直到操作完成才返回。
> * **非阻塞**：应用程序调用 I/O 函数后，如果数据还没准备好，函数会**立即返回**一个错误码，线程不会被挂起，可以继续执行其他任务。

### 1.阻塞I/O
如果所调用的I/O函数没有完成相关的功能，则会使进程**挂起**，直到相关数据到达才会返回。一直等待相关数据到达，然后从内核空间拷贝到用户空间(此阶段仍然是阻塞的)。

### 2.非阻塞I/O
当请求的I/O操作不能完成时，不会让进程挂起，立即返回。程序会一直轮询，直到完成相关的功能。然后进程仍然会**阻塞**将数据从内核拷贝到用户空间。

### 3.I/O复用
进程将一组文件描述符传递给I/O复用相关的函数(如`select`/`poll`/`epoll`)，同时监视多个文件描述符。这个监视的过程是**阻塞**的。当其中一个或多个文件描述符**准备就绪**时，函数会返回，并告知哪些文件描述符是可读/可写的。然后从内核拷贝数据到用户空间。

### 4.信号驱动I/O
进程要定义一个信号处理程序，系统可以**自动捕获特定信号**的到来，从而启动I/O。这是由内核通知用户何时可以启动一个I/O操作决定的。它是**非阻塞**的。当有就绪的数据时，内核就向该进程发送SIGIO信号。

### 5.异步I/O
进程让内核启动I/O操作，并在内核完成相关功能后**直接拷贝**数据到用户空间，整个操作完成后，内核通过信号或回调函数**通知**进程。

### 6.总结

| 特性/模型          | **阻塞I/O **   | **非阻塞I/O **    | **信号驱动I/O**       | **I/O多路复用**               | **异步I/O (AIO)**     |
| :------------- | :----------- | :------------- | :---------------- | :------------------------ | :------------------ |
| **模型分类**       | 同步阻塞         | 同步非阻塞          | 同步非阻塞             | 同步非阻塞                     | **异步**非阻塞           |
| **第一阶段**(等待数据) | **阻塞**       | **非阻塞**(需用户轮询) | **非阻塞**(内核发信号通知)  | **阻塞**在`select`/`epoll`上  | **非阻塞**(由内核处理)      |
| **第二阶段**(拷贝数据) | **阻塞**       | **阻塞**         | **阻塞**            | **阻塞**                    | **非阻塞**(由内核处理)      |
| **核心思想**       | 一个线程等一个连接    | 线程不断轮询“好了没”    | 内核发信号通知“好了”，应用再去读 | 一个线程等多个连接的“通知”            | 委托内核全权处理，完成后通知我     |
| **CPU占用**      | 低 (因线程休眠)    | **高** (因忙等待轮询) | 低                 | 低 (因线程在`select`休眠)        | 低                   |
| **优点**         | 简单易懂         | 不会阻塞线程         | 避免了轮询开销           | **高并发**，单线程处理多连接          | **并发性能最高**          |
| **缺点**         | **低并发**，资源浪费 | **CPU空转**，效率低  | 信号处理复杂，**扩展性差**   | 编程复杂，`select`有性能瓶颈        | **编程最复杂**，OS支持不完善   |


## 二、`select()`函数
`select()`允许一个**单进程**同时监控**多个FD**，监视它们是否有一个或多个FD"准备就绪"，而不需要为每个FD都创建一个专门的进程或者线程。

`select()`函数原型定义在`<sys/select.h>`头文件中，
``` C
#include <sys/select.h>

int select(int nfds,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *exceptfds,
           struct timeval *timeout);
```

### 1.nfds(int)
* 需要监视的FD中的最大值+1
* 内核利用这个值在文件描述符的范围内不断轮询

### 2.readfds(fd_set \*)
一个指向`fd_set`结构体的指针，用来监视FD的“可读”状态
**状态**：
- **调用前**：把所有关心“是否可读”的文件描述符放进这个集合。
    
- **返回后**：`select`会修改这个集合，只保留那些**已经就绪**（即可读）的文件描述符。

### 3.writefds(fd_set \*)
与`readfds`类似，但用于监视“可写”状态。

### 4.exceptfds(fd_set \*)
用于监视FD的"异常"状态。

### 5.timeout(struct timeval \*)
设置`select()`的监视超时时间。
* `struct timeval`结构包含秒（`sec`）和微秒（`usec`）。
* **三种模式**：
	* **`NULL`**：**永久阻塞**。`select`会一直等待，直到有一个文件描述符就绪。
    
	* **时间值设为0**：**完全不阻塞**。`select`会立即返回，不管是否有文件描述符就绪。这可以用于实现“轮询”（polling）。
    
	* **时间值大于0**：**等待指定时间**。`select`会等待指定的时间。如果在超时前有文件描述符就绪，它会立即返回；如果超时，它也会返回。

### 5.返回值
- **`> 0`**：返回就绪的文件描述符的总数。例如，如果`readfds`中有2个FD就绪，`writefds`中有1个FD就绪，则返回3。
- **`0`**：超时。在指定时间内没有任何文件描述符就绪。
- **`-1`**：发生错误（例如，被信号中断），此时`errno`会被设置。

>[! note] fd_set
>`fd_set` 本质上是一个位图（bitmap），你不能直接操作它，而应该使用下面这四个宏：
>- **`FD_ZERO(fd_set *set)`**
   > 
   > - **作用**：清空一个`fd_set`集合。在每次循环调用`select`之前都必须这样做。
   >     
>- **`FD_SET(int fd, fd_set *set)`**
  >  
   > - **作用**：将一个文件描述符`fd`添加到`set`集合中。
   >     
>- **`FD_CLR(int fd, fd_set *set)`**
   > 
  >  - **作用**：将一个文件描述符`fd`从`set`集合中移除。
>        
>- **`FD_ISSET(int fd, fd_set *set)`**
   > 
  >  - **作用**：在`select`返回后，用这个宏来检查某个文件描述符`fd`是否仍然在`set`集合中（即是否处于就绪状态）。


## 三、实验内容

### 1.编译程序
在Linux源码中打开终端，输入如下命令：
``` shell
cd ./linux/application/select
make
```
即可完成程序的编译

### 2.将程序复制到开发板
将SD卡插入电脑中，将编译好的程序(默认名称为`select`，在Linux源码/linux/application/select目录下)复制到SD卡。
将SD卡插入开发板，打开开发板终端，进入SD卡的挂载目录，找到`select`程序所在位置。
输入命令`./select`即可运行程序
![[Pasted image 20250716200639.png]]


>[!warning]
>因为`select()`函数运行后会修改`readfds`和`writefds`合集的内容，所以实验给出的代码并不规范。
>建议在循环中每次执行`select()`之前重新初始化两个合集或者将合集的值赋值给临时合集
>我给出赋值给临时合集的代码，放在`docs`目录下
