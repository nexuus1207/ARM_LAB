## 1.函数介绍
文件I/O操作的系统调用，主要用到5个函数：open()、read()、write()、lseek()和close()。这些函数的特点是不带缓存，直接对文件（包括设备）进行读写操作。这些函数虽然不是ANSI C的组成部分，但是是Posix的组成部分。
>[!note] Posix
>**POSIX**，全称为**可移植操作系统接口**，它的主要目标是为了**增强不同操作系统之间的兼容性**，让软件开发者可以让程序在多种系统上运行，而无需对代码进行过大的改动。

### (1) open()
`open()`函数的主要作用是**打开或创建**一个文件。

`open`函数在C语言中的原型定义在`<fcntl.h>`头文件中：
``` C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```
可以看到，`open` 有两种形式。是否需要第三个参数 `mode` 取决于第二个参数 `flags` 的值。

* **`pathname`**: 一个字符串，表示你想要打开或创建的文件的路径（文件名）。
* **`flags`**: 一个整数，用来指定文件的打开方式。它是由一个或多个常量通过按位或（`|`）操作符组合而成的。
*  **`mode`**: 仅当 `flags`flags` 中包含 `O_CREAT` 标志时，这个参数才有效。它用于指定新创建文件的权限。
**返回值：**
* **成功**：返回一个唯一的、非负的整数，即文件描述符。
* **失败**：返回`-1`，并设置全局变量`errno`来表示具体的错误原因，可以使用`perror()`函数打印出错误信息。
#### a.`flags`参数详解
`flags`参数控制着文件的打开行为，是`open()`的核心参数。以下是常用的标志：
**访问模式（必须指定其一）**
* **`O_RDONLY`**:以**只读模式**打开文件。
* **`O_WRONLY`**:以**只写模式**打开文件。
* **`O_RDWR`**:以**读写模式**打开文件。

**可选标志(通过或的方式与访问模式组合使用)**
* **`O_CREAT`**：如果文件**不存在**，则**创建**它。使用此标志时，必须同时提供第三个参数`mode`来指定新文件的权限。
* **`O_TRUNC`**：如果文件已存在并且是可写的，则将其长度**截断为0**。也就是会清空文件原有的所有内容。
* **`OAPPEND`**：在写入数据时，将数据追加到文件的**末尾**，而不是从头覆盖。每次`write`都会将文件指针移动到文件数据末尾。

#### b.`mode`参数详解
当 `flags` 中包含 `O_CREAT` 时，`mode` 参数就派上用场了。它用来定义新创建文件的访问权限。这个参数也是由多个常量通过按位或 (`|`) 组合而成。
这些常量定义在 `<sys/stat.h>` 中，常见的有：

- **`S_IRUSR`**: (Read by User) 文件所有者可读。
- **`S_IWUSR`**: (Write by User) 文件所有者可写。
- **`S_IXUSR`**: (Execute by User) 文件所有者可执行。

- **`S_IRGRP`**: (Read by Group) 文件所属组可读。
- **`S_IWGRP`**: (Write by Group) 文件所属组可写。
- **`S_IXGRP`**: (Execute by Group) 文件所属组可执行。

- **`S_IROTH`**: (Read by Others) 其他用户可读。
- **`S_IWOTH`**: (Write by Others) 其他用户可写。
- **`S_IXOTH`**: (Execute by Others) 其他用户可执行。
#### c.返回值
* 成功时：返回一个新的**文件描述符**。
* 失败时：返回`-1`，并设置全局变量`errno`表示具体的错误原因。

### (2) read()

`read()`函数直接与操作系统内核交互，将数据从内核空间缓冲区复制到用户空间的缓冲区。

`read()`函数在C语言中定义在<unistd.h>头文件中，其原型如下：
``` C
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
```

#### a. int fd参数
* `fd`参数中文名称为**文件描述符**，它在内核中**唯一**标识一个已打开的文件。当你的程序打开一个文件或创建一个管道/套接字时，内核会返回一个文件描述符。
* 在任何一个Linux进程启动时，默认会打开三个标准的文件描述符：
	* `0`: 标准输入 (Standard Input, `STDIN_FILENO`)
	* `1`: 标准输出 (Standard Output, `STDOUT_FILENO`)
	* `2`: 标准错误 (Standard Error, `STDERR_FILENO`)

#### b. void\*buf参数
- 这是一个指向**内存缓冲区**的指针，`read` 函数会将读取到的数据存放在这个缓冲区里。    
- `buf` 必须指向一块**已经分配好**的、**足够大**的内存空间，以容纳最多 `count` 个字节的数据。通常，会定义一个字符数组或使用 `malloc` 来分配这块内存。
- `void *` 类型表示它可以是任何类型的指针，因为 `read` 只关心原始的字节流。

#### c.size_t count参数
* `count`指定了**期望**从文件中读取的最大字节数。
* `read`函数实际读取的字节数会**小于等于**count。

#### d.返回值
`read()`函数的返回值为`sszie_t`类型，它有三种可能的情况：
* 返回值>0
	* 表示**成功读取**文件的字节数。
	* 当文件中剩余的字节数少于`count`或者读取时被某个信号打断时返回值会小于`count`
* 返回值\==0
	* 表示已经读到了**文件末尾(EOF)**。此时再对这个文件描述符调用`read()`将一直返回0。
* 返回值\==-1
	* 表示**读取错误**，错误的原因被存储在全局变量`errno`中。可以使用`perror()`查看错误原因。


### (3) write()
`write()`函数用于将数据**写入**一个文件描述符。它提供了一个直接与系统内核交互来执行写操作的接口。
`write()`函数在C语言中，原型声明在<unistd.h>头文件中：
``` C
#include <unistd.h>

ssize_t write(int fd,const void *buf,size_t count);
```
其参数和返回值与`read()函数`一致，这里就不再赘述。

### (4) lseek()
`lseek()`函数用于**重新定位**文件描述符的读/写文件偏移量。简而言之，使用`lseek()`函数可以在文件内移动读写指针，从而实现对文件的随机访问。

`lseek()`函数C语言原型定义在<unistd.h>头文件，使用时还需要包含<sys/types.h>。
``` C
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

#### a. int fd参数
* 文件描述符，与`read()`函数一致。这个`fd`通常是`open()`函数成功调用后的返回值。
#### b. off_t offset
* 这是一个长整型数，表示指针**偏移量**，单位是字节。
* 它的计算方式取决于`whence`参数。
* 当`offset`为正数时，指针向文件末尾方向移动。
* 当`offset`为负数时，指针向文件开头方向移动。
* 当`offset`为0时，指针不移动，可用于获取文件指针当前位置。
#### c. int whence
* 这个参数为`offset`提供了**参照基准点**，它有三个标准的宏定义。
* `SEEK_SET`：从**文件开头**开始计算。
* `SEEK_CUR`：从**当前指针位置**开始计算。
* `SEEK_END`：从**文件末尾**开始计算。
#### d.返回值
* 成功时：`lseek`返回一个新的偏移量，该值是从**文件开头**算起的字节数。
* 失败时：返回`-1`，并设置全局变量`errno`表示具体错误原因。

>[! Warning]
>`lseek()`函数仅仅移动了文件指针，并不会引起任何IO操作。当文件指针超出文件末尾的位置时，文件会被拓展。若在超出位置写入数据，与原来文件末尾之间会用0来填充。

### (5) close()

`close()` 函数的核心作用是**通知操作系统释放一个先前被程序占用的资源**，主要实现以下几个关键目的：
1.**防止资源泄露**：操作系统对一个程序能打开的文件数量有限制。调用 `close()` 会释放文件描述符，使其能被重新使用，避免程序因耗尽资源而崩溃。
2.**确保数据完整性**：对于带有缓冲区的写入操作，`close()` 会确保将缓冲区中剩余的数据全部写入到磁盘，防止数据丢失。
3.**解除文件锁定**：关闭文件可以解除可能存在的锁定，允许其他程序或进程访问该文件。

`close()` 函数在C语言中定义在<unistd.h>头文件中，其原型如下：
``` C
#include <unistd.h>

int close(int fd);
```

* **参数 `fd`** ：是一个整型参数，代表文件描述符。文件描述符是一个非负整数，它是在进程级别上用来唯一标识一个打开的文件的“句柄”。这个值通常由 `open()`、`creat()`、`socket()`、`pipe()` 或 `dup()` 等系统调用返回。
* **返回值:**
	 * **成功:** 如果函数成功关闭了文件描述符，它会返回 `0`。
	* **失败:** 如果发生错误，`close()` 会返回 `-1`，并设置全局变量 `errno` 来指明具体的错误类型。
>[! Warning]
>即使调用`close()`很少见到失败的情况，但是为了程序的健壮性，我们必须检测其返回值。

>[! Question] 为何**必须**调用close()?
>忽略调用`close()`会导致 **"文件描述符泄露"**。
>进程能打开的文件描述符是有限的。如果在一个循环中不断地 `open()` 文件而从不 `close()`，程序最终会因为无法获取新的文件描述符而失败，导致无法打开新文件、建立新网络连接等。
>虽然 `close()` 本身不保证将缓冲区数据刷新到磁盘，但不关闭文件描述符会使文件一直处于打开状态，增加了在程序异常退出时数据未被完全写入的风险。



## 2.Linux应用

### (1) 实验内容
&emsp;&emsp;实验的基本功能是从一个文件（源文件）中读取最后10KB数据并复制到另一个文件（目标文件）。在实例中源文件是以只读方式打开的，目标文件是以只写方式打开（可以是读/写方式）的。若目标文件不存在，可以创建并设置权限的初始值为644。

>[! note]  文件权限
>Linux下设置文件权限使用数字表示不同用户或用户组的权限。一般是三个数字：第一个数字表示文件所有者的权限；第二个数字表示与文件所有者同属一个用户组的其他用户的权限；第三个数字表示其它用户组的权限。
>权限分为三种：读（r=4），写（w=2），执行（x=1）。综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。

### (2) 实验步骤

#### a.程序编译
将资料中的`io.tar.gz`拷贝到Linux源码根目录下的`./linux/application`，在该目录下打开终端，输入
``` shell
tar -xzvf io.tar.gz
cd io
make
```
 即可完成程序的编译工作。

#### b.程序拷贝
将SD卡插入电脑中，将io文件夹拷贝到SD卡中

将SD插入开发板，开启电源，进入linux系统。
首先创建一个文件夹挂载SD卡
``` shell
mkdir /mnt/sd
```
然后对SD卡进行挂载
``` shell
mount /dev/mmcblk1p1 /mnt/sd
cd /mnt/sd
```
即可查看到SD卡中的内容

#### c.验证程序
在开发板终端输入如下命令：
``` shell
cd io
./copy_file
cat dest_file
```
即可查看到我们程序运行后生成的文件内容。


## 3.程序拓展
在Linux中我们经常会使用`cp source target`这种方式复制文件，有了以上的基础我们可以对实验中的程序进行修改，自己实现该命令。
修改后的参考程序放到了docs文件夹中。